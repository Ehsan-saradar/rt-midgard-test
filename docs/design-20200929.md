Topics for discussion
- What a sensible long term design could be.
- What steps we can take into that direction which makes v2/actions fast now.

Job of Midgard: fetching(a), parsing(b), aggregating(c), serving(d)
a) take events which have key value pairs.
  * Currently fetching is done together with parsing (b)
  * We might choose to store the raw events in SQL and do the parsing separately, so if we have to change
    parsing logic we don't need to fetch everything again.
b) parse the events, map them into separate tables.
  * Currently this is written in go, but if we store the raw events we may choose to do it in SQL.
  * This also contains calculation of the prices, which logically could be part of (c)
  * We could change parsing to SQL if it has advantages.
  * We need to add order within a block to the events to have full ordering over events.
c) calculate aggregations over them.
  * in order to have quicker queries we set up aggregation tables in timescale.
  * unfortunately timescale aggregations work on simple tables only, not on views.
  * We already have one instance where we created a view and a materialized table with a watermark.
  * We need more complicated aggregations, e.g. we want to create an actions view which is fast.
  * We may choose to do the aggregations in golang or in SQL.
    - Doing it in golang is easer to understand for new devs.
    - Creating the datastructures in golang might have limitations. E.g. it's good for latest prices,
      but not good for metrics where we need full history (exalmple?)
d) serve queries quickly
  * Originally Midgard was serving in O(number of events). This is still the case for v2/actions
  * Currently Midgard is mostly O(number of days).
  * We need to make it O(log(number of events))

An orthogonal long term idea: Indexing (a+b+c) might become slow. If we have an instance of Midgard
after indexing we can clone it for fast startup. We might have a MapReduce kind of thing where Midgards
work together to make a fast sync. We would need to change the price calculation and other aggregates
which need a state updated in order. It's doable, but it's nontrivial. We should consider keeping the possibility
for this option.

Main question currently: How to calculate the aggregations (c)?
* It's not immutable, parts of the action change (e.g. pending->success).
* Should we have multiple tables with or update existing rows?
* Should it the generation be in SQL or Go?
* Should we use timescale or do it ourselves with watermarks?
* How to make v2/actions pagination fast? Continuation token? Date filters? Number of results estimate?
* How to make v2/actions fast with filters (address, txid, pool, type)?
* How to make sure that Midgard reports healthy only after aggregations?

Another orthogonal idea:
* Should Midgard team export the first few Million blocks in a file somewhere and commit the hash of
  it in the code?
